# Baking Rack
[![Tests](https://github.com/dcunning/baking_rack/workflows/Tests/badge.svg)](https://github.com/dcunning/baking_rack/actions?query=workflow%3ATests)

Bake and Push static webpages generated by [a Rack application](https://github.com/rack/rack/).

![Baking Rack Logo](https://github.com/dcunning/baking_rack/blob/main/logo.png?raw=true)

## Table of Contents

- [Why?](#why)
- [Getting Started](#getting-started)
- [Usage](#usage)
  - [Ruby on Rails](#ruby-on-rails)
  - [AWS S3](#aws-s3)
- [Contributing](#contributing)
- [Versioning](#versioning)
- [License](#license)

## Why?

### Why static webpages?

When paired with a good hosting service, static webpages are cheaper to host, easier to maintain, and harder to hack than dynamic ones because there are less moving parts.

### Why one more Ruby static webpage generator?

`BakingRack` is a narrowly-focused library, not an all-encompassing framework.

Jekyll, Middleman, Nanoc, and Bridgetown are frameworks that define how your site is organized. `BakingRack` is only interested in your site being [a Rack app](https://github.com/rack/rack/) (protip: all those frameworks support Rack) in order to gather its static pages and publish them to a static webserver or CDN.

## Getting Started

Start by including `baking_rack` in your Gemfile:

```ruby
gem 'baking_rack'
```

Then run `bundle install`.

## Usage

Ruby API:

```ruby
directory = "site"

# Step 1: build the webpages
BakingRack::Build.run(app: Rails.application) do |b|
  b.domain_name = "my-domain.com"

  b.define_static_routes do
    # Render this explicit path using your Rack app.
    get "/about.html"

    # Collect routes from static data
    BlogPost.find_each do |post|
      get post.path
    end

    # Expect statuses other than 200
    get "/404.html", status: 404
  end
end

# Step 2: deploy what was built
BakingRack::AwsS3::Deployer.run(
  bucket_name: "my-bucket.com",
)
```

CLI:

```ruby
# config/initializers/baking_rack.rb (in Rails)

BakingRack.config do |c|
  c.builder = BakingRack::Builder.new
  c.deployer = BakingRack::Deployers::AwsS3.new

  c.define_static_routes do
    # same usage as BakingRack::Build.run above
  end
end
```

```bash
# view available commands
$ bundle exec baking_rack help

# view a specific command's options
$ bundle exec baking_rack help [COMMAND]

# perform the build and deploy
$ bundle exec baking_rack publish
```

### Dry Run

Deployers support the `dry_run` keyword argument which instructs it to output what will be deployed without actually performing it.

### Ruby on Rails

`BakingRack` provides some additional help for building static webpages from Ruby on Rails applications, just use its custom builder class:

```ruby
BakingRack::Rails::Build.run(build_directory: directory) do |b|
  b.static_routes do
    # path helpers are exposed here
    get root_path
  end
end
```

Intelligent defaults

* `app` defaults to `Rails.application`
* `domain_name` defaults to `Rails.application.config.hosts.first`

### AWS S3

Add another gem to your Gemfile:

```ruby
gem "aws-sdk-s3", require: false
```

Your Access Key and Secret Access Keys are read from your AWS config or ENV.

```ruby
BakingRack::AwsS3::Deployer.new(
  bucket_name: "your-bucket.com", # bucket containing your static files
)
```

If you want terraform to set up your AWS resources required for hosting on S3 and serving via CloudFront, run the following commands:

```bash
# Generate the terraform files
$ bundle exec baking_rack install:aws_s3_terraform

# https://developer.hashicorp.com/terraform/tutorials/aws-get-started
$ cd terraform
$ terraform init
$ terraform apply
$ cd ..

# Generate a GitHub workflow to publish the latest `main` to the S3 bucket
$ bundle exec baking_rack install:github_publish_workflow
```

## Contributing

If you have problems, please create a [GitHub Issue](/.github/ISSUE_TEMPLATE/bug-report.md).

## Versioning

`baking_rack` follows Semantic Versioning 2.0 as defined at https://semver.org.

## License

This code is free to use under the terms of the MIT license.
